import email
import imaplib
import json
import logging

from datetime import datetime, time, date, timedelta
from logging.config import dictConfig
from twisted.internet import task, reactor

from telegram.ext import Updater, CommandHandler, \
    MessageHandler, Filters

logging_config = {
    'version': 1,
    'formatters': {
        'default_format': {
            'format': '%(asctime)s %(name)-12s %(levelname)-8s %(message)s'
        }
    },
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'formatter': 'default_format',
            'level': logging.DEBUG
        }
    },
    'root': {
        'handlers': ['console'],
        'level': logging.DEBUG
    }
}
dictConfig(logging_config)
logger = logging.getLogger()

EMAIL_ACCOUNT = "tudresdenstundenplan@gmail.com"
EMAIL_PASSWORD = "PQB3yZNHAzUD6mIOa5suxV9e8UeNx7"
TELEGRAM_API_TOKEN = "487297199:AAEGf9Hus-MTRxwxDh3cSlFw-234Ak_mAeI"

WANTED_SUBJECT = 'Timetable update'
NEEDED_KEYS = [u'firstClass', u'username', u'startMin', u'break', u'lastClass',
               u'length', u'identifier', u'data', u'startHour']

logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)


class MailWatcher(object):

    processed_ids = list()

    def __init__(self, account, password):
        self.mail_client = imaplib.IMAP4_SSL('imap.gmail.com')
        self.mail_client.login(EMAIL_ACCOUNT, EMAIL_PASSWORD)
        self.mail_client.select('inbox')

    def check_new_messages(self):
        self.mail_client.select('inbox')
        all_uids_in_inbox = self.get_uids()
        new_uids = [uid for uid in all_uids_in_inbox if uid not in self.processed_ids]
        logger.debug('Found {} new mails'.format(len(new_uids)))

        new_configs = list()

        for new_uid in new_uids:
            new_config = self.process_message(new_uid)
            if new_config:
                new_configs.append(new_config)

        return new_configs

    def get_uids(self):
        result, data = self.mail_client.uid('search', None, 'ALL')
        return data[0].split()

    def get_mail(self, uid):
        result, data = self.mail_client.uid('fetch', uid, '(RFC822)')
        return email.message_from_string(data[0][1])

    def get_attachment_content(self, mail):
        # get attachment payload of email

        if mail.get_content_maintype() == 'multipart': # only multipart emails have an attachment
            for part_number, part in enumerate(mail.walk()):

                # check if mail subject is what we are
                # looking for here
                if not part_number:
                    if part['Subject'] != WANTED_SUBJECT:
                        logger.debug("Found email, but with wrong subject")
                        return

                # find the attachment part
                if part.get_content_maintype() == 'multipart': continue
                if part.get('Content-Disposition') is None: continue

                # save the attachment in the program directory
                try:
                    json_data = json.loads(part.get_payload(decode=True))
                    logger.debug("Successfully read json attachment")
                    return json_data
                except ValueError as e:
                    logger.debug("Error reading email attachment")
                    return

        return

    def get_timetable_config_from_mail(self, mail):
        data = self.get_attachment_content(mail)

        # validate that the attachment was valid
        if data and all([key in data for key in NEEDED_KEYS]):
            logger.info("Successfully fetched data for {}".format(data['identifier']))
            return data
        else:
            logger.debug("Got invalid attachment, some keys were missing")
            return

    def process_message(self, uid):
        email = self.get_mail(uid)
        timetable_config = self.get_timetable_config_from_mail(email)

        self.processed_ids.append(uid)
        if not timetable_config:
            return None

        return timetable_config


class ReminderBot(object):

    # Dictionary containing data about registered users
    # keys:     corresponding device ids (generated by app)
    # values:   chat ids
    registered_devices = dict()

    # Dictionary with all active reminders
    # keys:     device ids of users
    # values:   list of dicts representing reminders
    #           contains time and type/name of lesson
    reminders = dict()

    remind_in_advance_time = 10

    def __init__(self, token):
        self.updater = Updater(token=token)
        self.dispatcher = self.updater.dispatcher

        self.configure_handlers()

    def configure_handlers(self):
        # Start handler
        start_handler = CommandHandler('start', self.start)
        self.dispatcher.add_handler(start_handler)

        # Registration handler
        registration_handler = CommandHandler('register', self.register, pass_args=True)
        self.dispatcher.add_handler(registration_handler)

    def start(self, bot, update):
        update.message.reply_text("Hey, ich bin ein Alarm-Bot, der dich immer an deinen Unterricht erinnert.")
        if self.check_user_is_registered(update.message.chat_id):
            update.message.reply_text("Du bist bereits registriert.")
        else:
            update.message.reply_text("Bitte registriere dich zuerst.")

    def register(self, bot, update, args):
        user_device_id = args[0]
        if self.check_user_is_registered(update.message.chat_id):
            update.message.reply_text("Du bist bereits registriert.")
        else:
            self.registered_devices[user_device_id] = update.message.chat_id
            update.message.reply_text("Danke, du bist jetzt registriert.")

        if user_device_id in self.reminders:
            update.message.reply_text('Es liegen bereits Unterrichtsdaten von dir vor!')

    def unregister(self, bot, update):
        user_chat_id = update.message.chat_id

        if user_chat_id not in self.registered_devices.values():
            update.message.reply_text("Du warst noch gar nicht registriert.")
            return

        for device_id, chat_id in self.registered_devices.items():
            if chat_id == user_chat_id:
                # delete chat_id as registered user
                del self.registered_devices[device_id]

                # delete config of user
                if device_id in self.reminders:
                    del self.reminders[device_id]

    def add_new_config(self, config_data):
        logger.debug('Add new config for {} to ReminderBot'.format(config_data.get('identifier', None)))
        start_time = time(
            hour=int(config_data['startHour']),
            minute=int(config_data['startMin']))

        lesson_length = int(config_data['length'])
        break_length = int(config_data['break'])

        lessons_raw_data = config_data['data']
        device_id = config_data['identifier']

        if device_id not in self.reminders:
            self.reminders[device_id] = list()

        for day in range(0, 5): # 0 is Monday, 4 is Friday
            lessons_at_day = [row[day] for row in lessons_raw_data]
            for lesson_number, lesson in enumerate(lessons_at_day):
                if lesson:
                    self.reminders[device_id].append({
                        'time': self.calculate_reminder_time(
                            start_time, lesson_length, break_length, lesson_number
                        ),
                        'weekday': day,
                        'lesson': lesson
                    })

    def calculate_reminder_time(self, start_time, lesson_length, break_length, lesson_number):
        minutes_to_add = lesson_number*lesson_length + lesson_number * break_length
        return (datetime.combine(date.today(), start_time) +
                timedelta(hours=int(minutes_to_add)/60, minutes=int(minutes_to_add % 60))).time()

    def check_reminders(self):
        weekday = date.today().weekday()

        # don't check on weekend
        if weekday > 4:
            return

        now = (datetime.now() + timedelta(minutes=self.remind_in_advance_time))
        time_to_check = time(hour=now.hour, minute=now.minute)

        # check for each user if he or she has to
        # reminded of some lesson
        for device_id in self.registered_devices:
            reminders = self.reminders[device_id]
            for user_reminder in reminders:
                if user_reminder['weekday'] == weekday and user_reminder['time'] == time_to_check:
                    logger.info('Send reminder to {} that he/she has {}'.format(device_id, user_reminder['lesson']))
                    self.send_reminder_to_user(
                       self.registered_devices[device_id],
                       user_reminder['lesson']
                    )

    def send_reminder_to_user(self, chat_id, lesson):
        self.updater.bot.send_message(
            chat_id=chat_id,
            text="Du hast in 10 Minuten {}".format(lesson)
        )

    def run(self):
        self.updater.start_polling()

    def stop(self):
        self.updater.stop()

    # Helper methods
    # --------------
    def check_user_is_registered(self, chat_id):
        return chat_id in self.registered_devices.values()


if __name__ == '__main__':
    mail_watcher = MailWatcher(EMAIL_ACCOUNT, EMAIL_ACCOUNT)

    reminderBot = ReminderBot(TELEGRAM_API_TOKEN)
    reminderBot.updater.stop()
    reminderBot.run()

    def regularly_check():
        logger.debug('Check for new email and due reminders')
        new_configs = mail_watcher.check_new_messages()
        for new_config in new_configs:
            reminderBot.add_new_config(new_config)
        reminderBot.check_reminders()

    regularly_check_task = task.LoopingCall(regularly_check)
    regularly_check_task.start(60.0)
    reactor.run()


